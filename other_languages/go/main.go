package main

import (
	"encoding/binary"
	"fmt"

	"golang.org/x/crypto/sha3"
)

func main() {
	fmt.Println("Hello, World!")
	fmt.Println("ML-KEM-768")
	a := sampleNTT([]byte{0}, 0, 0)
	fmt.Println(a)
	//[2612 1755 799 127 2685 2707 922 2901 2411 800 2112 3201 3166 2424 1303 151 1751 3280 1248 1348 1626 3233 173 2588 1296 660 151 1958 1106 3114 1623 1659 2285 1793 1636 757 1519 2638 2014 1543 2966 365 1017 251 1040 1206 2006 799 2624 1098 1015 436 1558 2952 272 2773 2281 2815 14 1721 3277 3019 2244 14 2703 1778 1304 1412 2125 3293 2462 1494 3021 710 3161 882 1749 206 2914 882 2101 2959 1688 316 149 2692 1027 3046 3263 1076 2867 2026 3064 882 1691 2290 2237 2186 304 2206 3202 2708 2674 2040 2340 2324 1228 2114 877 3093 2201 2759 1859 2762 2506 200 852 2825 2984 2866 3076 1383 835 1918 395 829 1749 3177 2376 2283 2277 2045 3020 2313 2072 1914 1750 1077 3134 1345 265 1417 2130 203 3000 771 624 3072 231 2648 3302 2534 3124 3179 563 1494 2022 3241 1250 697 1037 1396 35 3083 3218 372 526 407 611 2198 1489 2151 2815 641 3231 1494 3324 242 1110 3051 3223 3207 326 3062 2976 1119 867 444 505 2212 1066 1495 2805 282 2374 874 68 892 551 271 2894 1926 393 3066 1584 1901 1537 599 1465 1966 3067 539 53 1448 1795 218 1350 222 1640 1805 2636 2535 2751 1036 461 2298 2469 181 2030 3135 183 1909 935 585 700 840 677 1307 3257 2012 1914 3276 3184 2516 2121 950 728 2324 2793 1562 1470 114 2882 1954 921 651]
}

const (
	// ML-KEM global constants.
	n = 256
	q = 3329

	// ML-KEM-768 parameters. The code makes assumptions based on these values,
	// they can't be changed blindly.
	k  = 3
	η  = 2
	du = 10
	dv = 4

	// encodingSizeX is the byte size of a ringElement or nttElement encoded by
	// ByteEncode_X.
	encodingSize12 = n * 12 / 8
	encodingSize10 = n * 10 / 8
	encodingSize4  = n * 4 / 8
	encodingSize1  = n * 1 / 8

	messageSize       = encodingSize1
	decryptionKeySize = k * encodingSize12
	encryptionKeySize = k*encodingSize12 + 32

	CiphertextSize       = k*encodingSize10 + encodingSize4
	EncapsulationKeySize = encryptionKeySize
	DecapsulationKeySize = decryptionKeySize + encryptionKeySize + 32 + 32
	SharedKeySize        = 32
	SeedSize             = 32 + 32
)

// fieldElement is an integer modulo q, an element of ℤ_q. It is always reduced.
type fieldElement uint16

// nttElement is an NTT representation, an element of T_q, represented as an
// array according to FIPS 203 (DRAFT), Section 2.4.
type nttElement [n]fieldElement

// sampleNTT draws a uniformly random nttElement from a stream of uniformly
// random bytes generated by the XOF function, according to FIPS 203 (DRAFT),
// Algorithm 6 and Definition 4.2.
func sampleNTT(rho []byte, ii, jj byte) nttElement {
	B := sha3.NewShake128()
	B.Write(rho)
	B.Write([]byte{ii, jj})

	// SampleNTT essentially draws 12 bits at a time from r, interprets them in
	// little-endian, and rejects values higher than q, until it drew 256
	// values. (The rejection rate is approximately 19%.)
	//
	// To do this from a bytes stream, it draws three bytes at a time, and
	// splits them into two uint16 appropriately masked.
	//
	//               r₀              r₁              r₂
	//       |- - - - - - - -|- - - - - - - -|- - - - - - - -|
	//
	//               Uint16(r₀ || r₁)
	//       |- - - - - - - - - - - - - - - -|
	//       |- - - - - - - - - - - -|
	//                   d₁
	//
	//                                Uint16(r₁ || r₂)
	//                       |- - - - - - - - - - - - - - - -|
	//                               |- - - - - - - - - - - -|
	//                                           d₂
	//
	// Note that in little-endian, the rightmost bits are the most significant
	// bits (dropped with a mask) and the leftmost bits are the least
	// significant bits (dropped with a right shift).

	var a nttElement
	var j int        // index into a
	var buf [24]byte // buffered reads from B
	off := len(buf)  // index into buf, starts in a "buffer fully consumed" state
	for {
		if off >= len(buf) {
			B.Read(buf[:])
			off = 0
		}
		d1 := binary.LittleEndian.Uint16(buf[off:]) & 0b1111_1111_1111
		d2 := binary.LittleEndian.Uint16(buf[off+1:]) >> 4
		off += 3
		if d1 < q {
			a[j] = fieldElement(d1)
			j++
		}
		if j >= len(a) {
			break
		}
		if d2 < q {
			a[j] = fieldElement(d2)
			j++
		}
		if j >= len(a) {
			break
		}
	}
	return a
}
